%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LIVECOMS ARTICLE TEMPLATE FOR BEST PRACTICES GUIDE
%%% ADAPTED FROM ELIFE ARTICLE TEMPLATE (8/10/2017)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PREAMBLE
\documentclass[9pt,tutorial]{livecoms}
% Use the 'onehalfspacing' option for 1.5 line spacing
% Use the 'doublespacing' option for 2.0 line spacing
% Use the 'lineno' option for adding line numbers.
% Use the "ASAPversion' option following article acceptance to add the DOI and relevant dates to the document footer.
% Use the 'pubversion' option for adding the citation and publication information to the document footer, when the LiveCoMS issue is finalized.
% The 'bestpractices' option for indicates that this is a best practices guide.
% Omit the bestpractices option to remove the marking as a LiveCoMS paper.
% Please note that these options may affect formatting.

% NOTES
% when importing references from EndNote, remove the type = {Journal Article}. It messes with the livecoms bibtex style somehow...
% Place a \@ between all-caps words and punctuation ("This is a sentence about GIST\@. This is ...")
% Place a protected space (~) between "Figure" and the reference. The same with tables.

\usepackage{lipsum} % Required to insert dummy text
\usepackage[version=4]{mhchem}
\usepackage{siunitx}
\DeclareSIUnit\Molar{M}
\usepackage[italic,LGRgreek]{mathastext}
\graphicspath{{figures/}}

\usepackage{listings}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% IMPORTANT USER CONFIGURATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\versionnumber}{1.3}  % you should update the minor version number in preprints and major version number of submissions.
\newcommand{\githubrepository}{\url{https://github.com/myaccount/homegithubrepository}}  %this should be the main github repository for this article

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ARTICLE SETUP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{This is the title [Article v\versionnumber]}

\author[1*]{Firstname Middlename Surname}
\author[1,2\authfn{1}\authfn{3}]{Firstname Middlename Familyname}
\author[2\authfn{1}\authfn{4}]{Firstname Initials Surname}
\author[2*]{Firstname Surname}
\affil[1]{Institution 1}
\affil[2]{Institution 2}

\corr{email1@example.com}{FMS}  % Correspondence emails.  FMS and FS are the appropriate authors initials.
\corr{email2@example.com}{FS}

\orcid{Author 1 name}{AAAA-BBBB-CCCC-DDDD}
\orcid{Author 2 name}{EEEE-FFFF-GGGG-HHHH}

\contrib[\authfn{1}]{These authors contributed equally to this work}
\contrib[\authfn{2}]{These authors also contributed equally to this work}

\presentadd[\authfn{3}]{Department, Institute, Country}
\presentadd[\authfn{4}]{Department, Institute, Country}

\blurb{This LiveCoMS document is maintained online on GitHub at \githubrepository; to provide feedback, suggestions, or help improve it, please visit the GitHub repository and participate via the issue tracker.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PUBLICATION INFORMATION
%%% Fill out these parameters when available
%%% These are used when the "pubversion" option is invoked
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pubDOI{10.XXXX/YYYYYYY}
\pubvolume{<volume>}
\pubissue{<issue>}
\pubyear{<year>}
\articlenum{<number>}
\datereceived{Day Month Year}
\dateaccepted{Day Month Year}


%%% Shortcuts and macros
\newcommand{\dgsolv}{\Delta G_\textup{solv}}
\newcommand{\software}{\texttt}
\newcommand{\todo}{\textcolor{red}}
\newcommand\inlinecode{\texttt}

% The \neq command looks messy by default. Replace it by our own makeshift version.
\renewcommand{\neq}{\setbox0\hbox{=}\rlap{\hbox to \wd0{\hss /\hss}}\box0}

\lstset{
	basicstyle=\ttfamily\footnotesize,
	inputencoding=utf8,
	extendedchars=true,
	literate={Å}{{\AA}}1
}
\lstdefinestyle{code}{}
\lstdefinestyle{python}{
	language=Python,
	stringstyle=\color[rgb]{1.0, 0, 0},
	commentstyle=\color[rgb]{0, 0, 0.6}
}
\lstset{style=code}

\DeclareSIUnit{\calorie}{cal}
\DeclareSIUnit{\kcalPerMolASqr}{\kilo\calorie\per\mole\per\angstrom\squared}

% TODO: delete for final build
\usepackage{pdfcomment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ARTICLE START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{frontmatter}
\maketitle

\begin{abstract}
Grid inhomogeneous solvation theory (GIST) is a method to compute the free energy of hydration of a compound on a 3-dimensional grid.
The high spatial resolution of the GIST output, as well as the decomposition into energy and entropy contributions, allow for highly detailed analyses on both proteins and small molecules. However, this versatility also comes with a higher entry barrier for new users.

In this tutorial, we aim to guide the reader through the most common steps involved in a GIST analysis at the example of the streptavidin-biotin complex.
Furthermore, we discuss the theory of GIST with a focus on practical aspects, and show several pitfalls and technical difficulties that may occur during a GIST study.
We assume familiarity with molecular dynamics (MD) simulations as well as the AmberTools package.

%This particular document provides a skeleton illustrating key sections for a Tutorial document.
%Please see the sample \texttt{sample-document.tex} in \url{github.com/livecomsjournal/article_templates/templates} for additional information on and examples of using the LiveCoMS LaTeX class.
%Here we also assume familiarity with LaTeX and knowledge of how to include figures, tables, etc.; if you want examples, see the sample just referenced.
%
%In your work, in this particular slot, please provide an abstract of no more than 250 words.
%Your abstract should explain the main contributions of your article, and should not contain any material that is not included in the main text.
%Please note that your abstract, plus the authorship material following it, must not extend beyond the title page or modifications to the LaTeX class will likely be needed.
\end{abstract}

\end{frontmatter}




\section{Introduction}
\todo{ (vah) Sources and better description of all these methods, more literature research, better flow }

\todo{IMO, our article looks too dry. We should have something nice (e.g., an illustration of the GIST method) on the 1st or 2nd page -fwa.}


Solvation thermodynamics govern any process involving solutes in a solvent.
%Solutes are constantly interacting with solvents in their environment, necessitating a good description of these interactions for accurate computational predictions. 
Especially the interaction with water is of utmost importance, as many biological processes occur in a aqueous environment. 
The free energy of solvation thereby strongly influences real-world problems of interest such as hydrophobic effects, the binding of ligands to a biomolecule, as well as the dynamics and folding of proteins.

The computational calculation of thermodynamical solvation properties is therefore of particular interest and has been tackled by a wide array of methods.
Quantum mechanical methods provide the most rigorous description of the underlying potential energy surface (PES) but suffer from high computational cost, allowing only the treatment of small systems and few solvent molecules. 
%More recently, QM/MM approaches and potentials based on deep learning \cite{Smith2017-ani} are trying to bridge the gap to computationally less demanding methods while keeping the accuracy of DFT methods.

Molecular mechanics based approaches describe the underlying PES through empirically fit force-fields, which reduce the computational demand of these calculations tremendously.
This allows for the treatment of large biological systems such as proteins in aqueous solution.
Implicit solvent methods such as MM/PBSA or MM/GBSA \cite{Sitkoff1994-pbsa,Kollman2000-mmpbsa} can quickly provide results for a large number of structures, but yield inaccurate results when compared to more rigorous explicit solvent methods \cite{Genheden2015-mmpbsa-review}.
On the other hand, the free energy of solvation can be calculated in a statistically rigorous way using explicit solvent simulations combined with alchemical methods such as free energy perturbation (FEP) \cite{Zwanzig1954-reweighting} or thermodynamic integration(TI) \cite{Kirkwood1935-ti}.
However, they are unable to provide a spatial interpretation of the results.
Furthermore, splitting the resulting free energy into contributions for the enthalpy and entropy is challenging \cite{Peter2004-alchemical-entropy}.
%Assuming sufficient sampling, they can accurately predict the free energy of solvation in the boundaries of the assumptions underlying their forcefield. 
%However, the seperation of enthalpic and entropic contributions to the free energy of solvation is difficult with these methods and localizing these contributions not easily possible.

Methods derived from statistical mechanics bridge this gap by providing three-dimensional resolution.
Two major groups of methods that fall into this group are those based on inhomogeneous solvation theory (IST) \cite{Lazaridis1998} and those based on the Ornstein--Zernike (OZ) equation \cite{Hansen2013-simple-liquids}.
The most important example of OZ-based methods is the reference interaction site model (RISM) \cite{Chandler1972-rism} as well as its extension to three dimensions (3D-RISM) \cite{Kovalenko1998-3drism}.
Those methods compute the solvent distributions by self-consistent solution of the OZ integral equation to predict solvation thermodynamics.
%The 3D-RISM approach allows for a decomposition into entropic and enthalpic terms as well as a full localization of the underlying distributions to the solute structure.

On the other hand, methods based on IST generally use a molecular solvent distribution obtained from an MD simulation to compute the free energy of hydration from its enthalpic and entropic contributions.
Examples of those methods include grid inhomogeneous solvation theory (GIST) \cite{Nguyen2012,Ramsey2016}, WaterMap \cite{Young2007-watermap,Abel2008-watermap}, SSTMap \cite{Haider2018-sstmap}, and STOW \cite{Li2012-stow}.
The main limitation of those methods is that they rely on an infinite expansion of the entropy in terms of the density distribution, which is truncated after the first or, sometimes, the second \cite{Nguyen2016-gist-second-order,Waibl2022-gist-solvents} term.
Nevertheless, they have been applied on a wide variety of problems involving both small molecules and biological systems.

In this tutorial, GIST is applied to calculate solution thermodynamics properties of interest. 

GIST is based on IST, solving the integral equations on a grid. 
This approach is more general than other IST-based methods because it accounts for all solvent regions rather than focusing on high-occopancy solvation sites.
%By simulating the dynamics of a solvent around the solute, GIST calculates thermodynamic properties for a standard solvation process as described by Ben-Naim \cite{ben-naim-book}.
It estimates the solvent density from a molecular dynamics (MD) trajectory and allows for a full localization of entropic and enthalpic contributions on the grid around the solute.
It has been shown that GIST can produce comparable accuracy to TI by approximating the higher-order entropies as a fraction of the first-order entropy (using a factor of \SI{-0.4} for water) \cite{Chen2021,Waibl2022-gist-solvents}.
%applying a linear correction factor (0.6 for water) to the first-order entropy as follows \cite{Chen2021,Waibl2022-gist-solvents}:
%\begin{equation}
%S^\textit{total} = S^\textit{1st-order} \times f
%\end{equation}

Recent work has improved the calculation speed tremendously, allowing for the treatment of large biological systems such as proteases or antibodies.
Furthermore, an implementation based on the particle mesh Ewald (PME) \cite{Darden1993-pme} method was presented, which improves the consistency between GIST and popular molecular dynamics engines. 
Yet further changes allow the inclusion of other rigid solvents than water or allow for the treatment of solvent mixtures and ions in solution.

While previous tutorials gave insightful pointers as to how to setup and run GIST calculations, the post-processing of such calculations was often treated less rigorously. While building on these tutorials, an updated guide to calculating solvation properties using GIST is therefore presented here to address the recent improvements to the method.

%Here you would explain what problem you are tackling and briefly motivate your work.
%
%In this particular template, we have removed most of the usage examples which occur in \texttt{sample-document.tex} to provide a minimal template you can modify; however, we retain a couple of examples illustrating more unusual features of our templates/article class, such as the checklists, and information on algorithms and pseudocode.
%
%Keep in mind, as you prepare your manuscript, that you should plan for a representative image  which will be used to highlight your article on the journal website and publications. Usually, this would be one of your figures, but it must also be uploaded separately upon article submission. We give specific guidelines for this image on the journal website in the section on article submission (see \url{https://livecomsjournal.github.io/authors/policies/index.html#article-submission}).
%
%Additionally, for well-formatted manuscripts, we recommend that you let LaTeX handle figure/table placement for you as much as possible, so please avoid specifying strenuous float instructions like `[h!]` and `[H]` as much as possible.

\subsection{Scope}

This tutorial provides an example of a GIST workflow that can be easily adapted towards different systems. 
In addition to a short introduction of the method and the theory behind it, we present an overview of the various different flavors of GIST methods.

Furthermore, a GIST study of the streptavidin-biotin complex is presented, which reflects on many common aspects of GIST studies.
Using this test system, we present solvation analysis of a small molecule (biotin) as well as a biomolecule (streptavidin).
We show how to interpret the three-dimensional contributions of solvation free energy in a binding pocket and around the ligand.

Additionally, we compute the binding contribution of the free energy of solvation, which requires accurate post-processing of the GIST outputs to avoid unfavorable summation of bias in the GIST calculation.
We believe that this example study covers a wide range of applications of the GIST method.

Furthermore, we discuss several technical aspects  and typical pitfalls of GIST analyses, such as the normalization of voxel values and how to deal with double counting of energy contributions. 
Additionally, we provide a python library to unify the analysis of GIST data produced by various versions of GIST and make the post-processing of GIST results more accessible.

After completing this tutorial, we expect the reader to be able to run their own GIST study. 

%Tutorials should endeavor to cover the specific task at hand, and also highlight how the steps might need to be modified (or additional care might need to be taken at particular points) to handle more general cases.
%
%The scope of the tutorial, as well as the expected proficiencies / outcomes for researchers who complete the tutorial, should be clearly defined.
%This will often happen in a specific section or subsection in the article itself.

\section{Prerequisites}
\todo{ (vah)  Improve flow and logical progression of prerquisites.}

%Here you would identify prerequisites/background knowledge that are assumed by your work, as well as any software/license requirements.

\subsection{Background knowledge}
This tutorial is aimed at users with a solid knowledge of molecular dynamics (MD) simulations.
The user should be able to run MD simulations and work with their output data.
Previous experience of GIST is not necessary.
However, we only provide a short explanation of the theory behind GIST and point the reader towards the primary sources for more detailed information.

The presented analyses are run in Python.
While no programming experience should be necessary to follow the tutorial, a basic understanding of Python is advantageous to adjust the code towards different requirements and use-cases. 
We provide a Jupyter notebook which contains the presented analyses. 
Therefore, an understanding of Jupyter notebooks is beneficial to reproduce the analyses.

\subsection{Software/system requirements}
%Tutorials should clearly define what system and/or software requirements the researcher will need to complete the tutorial (e.g., VMD version 1.9 or newer, AMBER, etc.). Tutorials requiring specific software packages must provide instructions and files for the referenced version of the software.
The main implementation of GIST is part of the MD analysis software \software{cpptraj} as part of AmberTools \cite{amber22}.

A recent version of \software{cpptraj} should be used, such as the one in AmberTools22 or an installation from GitHub (\url{https://github.com/Amber-MD/cpptraj}).
The closed-source Amber simulation engine is used in this tutorial to run the necessary MD simulations. 


The closed-source Amber simulation engine is used in this tutorial to run the necessary MD simulations.
If no Amber installation is available, the MD can be performed other simulation engines compatible with \software{cpptraj}.
If using GROMACS, we propose to prepare the structures and topologies with AmberTools and converting them using \software{acpype.py}.

\todo {If the simulation was ran using GROMACS, mdtraj can be used to convert GROMACS topology and trajectory in to an Amber file format.}
\todo {vah: I would remove this mention of GROMACs and replace it with a more generall comment. Or we could test if this actually works...}
In that way, a full Amber topology is available for GIST.

Also note that compressed trajectory formats such as \inlinecode{xtc} might bias the entropy calculation.

Furthermore, a recent Python version (>3.6) should be available with the following packages.
\begin{itemize}
	\item \software{gisttools} (\url{https://github.com/liedllab/gisttools})
	\item \software{mdtraj (\url{https://www.mdtraj.org/})}
\end{itemize}

We also show examples using the \software{gistpp} program, which can be obtained from \url{https://github.com/KurtzmanLab/Gist-Post-Processing} (code and documentation).

If the reader prefers to skip the MD and GIST calculation, we also provide the GIST output files with this tutorial, such that the post-processing can be done without any expensive calculations.
We also provide a Jupyter notebook \cite{Kluyver2016-jupyter,Granger2021-jupyter} with the presented analyses. 
We recommend JupyterLab to work with the notebook. Jupyter is available at \url{https://jupyter.org/}.

For the visualization of three-dimensional contributions we require molecular visualization software that can handle \software{OpenDX} files.
We recommend using a current version of \software{PyMol}\cite{pymol} or \software{VMD}\cite{vmd}.
\section{Theory}

GIST is an implementation of inhomogeneous fluid solvation theory (IST) \cite{Lazaridis1998} that discretizes the free energy of solvation $\dgsolv$ on a three-dimensional grid. 
It was first devised by Nguyen et al. \cite{Nguyen2012} and its implementation in \software{cpptraj} was thoroughly described by Ramsey et al. \cite{Ramsey2016}. % to overcome the limitation of IST which was commonly used for regions of high water occupancy and its implementation in \software{cpptraj} was thoroughly described in \cite{Ramsey2016}.
Here, we only provide a short overview of the theory behind GIST.
For more detailed information, we recommend one of the more recent publications on developments in GIST. \cite{Kraml2020,Chen2021}

\subsection{Solvation Entropy}

%The solvation entropy of a system is totality of the contribution of the  solute-water entropy and the water-water entropy. -- this is inconsistent with IST theory (fwa)


%\begin{equation}
%	\Delta S_\textit{solv} = \Delta S_\textit{sw} + \Delta S_\textit{ww}
%\end{equation}
%Here the solvation entropy is approximated from the contribution of solute-water interaction. 
%\textbf{STILLNEEDS REVISON + ADD CITATIONS} The quantity $k_\textit{b}$represents the Boltzman constant, 
%$\rho^\textit{o}$ is the bulk number density, $g_\textit{sw}\left(\textbf{r},\omega \right)$ is the solute-water 
%pair correlation function in the solute's frame of reference, \textbf{r} is the coordinates of the oxygen atom of the water molecule,  
%$\omega$ represents the Euler angles, and $\frac{1}{8\pi^2}$ is the volume of the orientational space, which acts as a normalization constant.
%In bulk and in regions where the orientational 
%entropy is uniform, the quantity $g_\textit{sw}\left(\textbf{r},\omega \right)$ is unity which leads to the first-order solvation entropy of 
%bulk to be zero. Also, this quantity reaches unity as the distance from the solute molecule increases which leads for the calculation of 
%the solvation entropy to be an approximation of the integral around the solute atom. 

IST expresses the free energy of solvation in terms of the solvent density in a coordinate system defined by the solute.
The solute is kept fixed in space, following the standard solvation process established by Ben-Naim \cite{ben-naim-book}.

For the entropy, this leads to an infinite expansion of correlations of increasing order.
In a slightly simplified view, the first order is the solvent density $g_\textit{sw}\left(\textbf{r},\omega \right)$ at each position $\textbf{r}$ and orientation $\omega$.
The first-order entropy omits all solvent-solvent (and higher) correlations, while the solute-solvent correlation is taken into account because the coordinates are relative to the solute.
Thus, it is called the solute-water entropy $S_{sw}$.
%The second order is the pair density, i.e., the probability of finding two solvent molecules in positions $\textbf{r}$ and $\textbf{r}^\prime$.

The solvent density is expressed relative to the bulk density $\rho^\textit{o}$. %$g_\textit{sw}\left(\textbf{r},\omega \right)$ is the solute-water 
%pair correlation function in the solute's frame of reference, \textbf{r} is the coordinates of the oxygen atom of the water molecule,  
%$\omega$ represents the Euler angles, and 
The entropy integral is also normalized by $8\pi^2$, which is the volume of the orientational space.
In bulk or at a high distance to the solute, the quantity $g_\textit{sw}\left(\textbf{r},\omega \right)$ is unity which leads to the first-order entropy of 
bulk to be zero. 
Therefore, no reference entropy needs to be computed unless there is a numeric bias, e.g., when the MD frames are not statistically independent due to insufficient spacing.
%Also, this quantity reaches unity as the distance from the solute molecule increases which leads for the calculation of 
%the solvation entropy to be an approximation of the integral around the solute atom. 
\begin{equation}
	\Delta S_\textit{solv}
	\approx \Delta S_\textit{sw}
	\newcommand{\gro}{g_{sw}(\textbf{r},\omega)}
	\equiv -R \frac{\rho^\textit{0}}{8\pi^\textit{2}} \int \gro \ln\gro d\textbf{r}d\omega
\end{equation}
\todo{We are inconsistent regarding R/kB; vah: Fixed. is it - tho? Papers seem to disagre }

The solvation entropy is further broken down in terms of the contribution from translational and orientational terms.
\begin{equation}
	\Delta S_\textit{solv} = \Delta S_\textit{trans} + \Delta S_\textit{orient}
\end{equation}

\subsection{Entropy Calculations in Cpptraj}
In \software{cpptraj} the calculation of  solvation entropy is handled into two methods.


The first method assumes that the distribution of the orientation $\omega$ is constant within a voxel $k$.
This allows for the splitting of the contributions of the translational and the orientational entropy. 
A first nearest neighbor (NN) approach is used to evaluate the density.
%The translational density $g_{NN}(\textbf{r})$ is expressed in reference to a homogeneous bulk solvent at the reference density, while the orientational density $g_{NN}(\omega)$ is expressed to a random placement of the number of solvents found in this voxel.
Both the translational ($g_{NN}(\textbf{r})$) and orientational ($g_{NN}(\omega)$) density are computed relative to a bulk solvent at the reference density $\rho^0$.

The average entropy contributions per solvent molecule in voxel $k$ are calculated as

\begin{equation}
	S_{k}^\textit{trans} = -R \left( \gamma + \frac{1}{N_\textit{k}} \sum _{i=1}^{N_k} \ln g_{NN, \textit{i}}(\textbf{r}) \right)
\end{equation}
and
\begin{equation}
	S_{k}^\textit{orient} = -R \left( \gamma + \frac{1}{N_k} \sum _{i=1}^{N_k} \ln g_{NN, i}(\omega) \right)
	,
\end{equation}
where $N_\textit{k}$ is the number of water molecules found in voxel k, $\gamma$ is Euler's constant that accounts for the bias in naive entropy estimator, and $g_\textit{NN}$ is the nearest neighbor estimate.

The second method directly calculates the solvation entropy by evaluating the six-dimensional integral (3 for position and 3 for orientation) 
using the nearest-neighbor approach. 
% Unlike the first method, the nearest neighbor estimate for the sixth-order entropy considers all the water found within the same and neighboring voxels. -- misleading because this is also done for S_trans (fwa)

\begin{equation}
g_\textit{vox} \left( \textbf{r}, \omega \right) \approx g_\textit{vox}(\textbf{r}) g_\textit{vox}(\omega)
\end{equation}

\begin{equation}
	S_\textit{k} = -R \left( \gamma + \frac{1}{N_\textit{k}} \sum _{i=1}^{N_k} \ln g_{NN, \textit{i}}(\textbf{r},\omega) \right)
\end{equation}


\subsection{Solvation Energy}
The solvation energy is readily calculated by summing up the contributions of the water-water interaction and the water-solute interaction.
\begin{equation}
	\Delta E_\textit{solv} = \Delta E_\textit{sw} + \Delta E_\textit{ww}
\end{equation}

The solute-solvent energy $E_{sw}$ can be expressed in terms of the solvent density and the potential $U_{sw}(\textbf{r},\omega)$ induced by the solute.
In practice, it is evaluated as the expectation value $\langle\cdot\rangle$ of the pairwise force field energy $U_{ij}$ between all solvent molecules in voxel $k$ and all solute atoms.

\begin{equation}
\begin{aligned}
\label{eq-esw}
	\Delta E_{sw}(\textbf{r}) \equiv& \frac{1}{8\pi^2} \int g_\textit{sw}\left(\omega|\textbf{r}\right) U_\textit{sw}\left(\textbf{r}, \omega\right) d\omega \\
	\Delta E_{sw,k}=& \left\langle \sum_i^{\textit{solvent},k} \; \sum_j^\textit{solute} U_{ij}\right\rangle
\end{aligned}
\end{equation}

To localize $E_{sw}$ on the three-dimensional grid, every energy term is assigned to the voxel $k$ holding the solvent, and the expectation value in Equation~\ref{eq-esw} is computed per voxel.
Similar to the entropy integrals, the solute-water solvation energy integral also decays with increasing distance from the solute. Hence, the solvation energy can be approximated by local spatial integrals. 

The solvent-solvent energy $E_{ww}$ is computed in a similar manner.
Again, it can be expressed in terms of density functions, but is practically computed as a sum over solvent-solvent interactions where one solvent is in voxel $k$.
In contrast to $E_{sw}$, $E_{ww}$ does not tend to zero in bulk.
Therefore, a reference energy corresponding to the average energy of a water molecule in bulk needs to be subtracted.

%However, there is a complication arising from this approximation. Water molecules outside the region of interest will also be accounted for in the pairwise water term. For example, given two different regions $R_a$ and $R_b$, will not sum up to the total energy of the two regions due to double counting.

\begin{equation}
\begin{aligned}
	\Delta E_{ww}(\textbf{r}) \equiv & \left(\frac{1}{8\pi^2} \right)^2 \rho^o \int g_\textit{sw}(\omega|\textbf{r}) \\
	& \times \left[g_\textit{sw}(\textbf{r}^\prime , \omega^\prime) - g^o_\textit{ww} (\textbf{r}, \omega, \textbf{r}^\prime, \omega^\prime )\right] \\
	& \times U_\textit{ww}(\textbf{r}, \omega, \textbf{r}^\prime, \omega^\prime)d\omega d\textbf{r}^\prime d\omega^\prime \\
	\Delta E_{ww,k} =& \frac{1}{N_k} \left\langle \sum_i^{\text{solvent},k} \; \sum_{j \neq i}^\text{solvent} U_{ij}\right\rangle - \left\langle E_{ww}^\text{bulk}\right\rangle
\end{aligned}
\end{equation}

%AFAIK, this was never done, since the pair interaction matrix Eij would have to be written out.
%There are two ways in which this double counting was accounted for in the original paper. First, using the water-displacement method. This method is applicable when a determining the energetic cost of kicking out a water molecule. 
%\begin{equation}
%	\Delta E^R_\textit{ww} = n^\textit{R} E^\textit{bulk}_\textit{ww} - E^\textit{R,corr}_\textit{ww}
%\end{equation}

%The second method uses normalized-water properties to account the difference in water properties of two different regions. The normalized water property is defined as the water property per water molecule. 
%\begin{equation}
%	\Delta E^\textit{R,norm}_\textit{ww} = E^\textit{R,norm}_\textit{ww} - 2E^\textit{bulk}_\textit{ww}
%\end{equation}

When computing the total $E_{ww}$ of the system, double-counting of interactions must be avoided.
The total solvent-solvent energy of the system is as follows.

\begin{equation}
\Delta E_{ww} = \int \frac{\Delta E_{ww}(\textbf{r})}{2} d\textbf{r}
\end{equation}

When water is replaced from a small region $R$ of interest, such as a single water molecule, almost all interactions are with water molecules outside of this region.
Therefore, there is no double counting, and the full solvent-solvent energy should be used.

\begin{equation}
\Delta E_{ww,R} = \int_R E_{ww}(\textbf{r}) d\textbf{r}
\end{equation}

When the region of interest $R$ comprises more than one molecule, interactions within this region are double-counted while interactions to the outside are not.
To take this into account, the solvent-solvent energy between each pair of voxels $E_{ww,kl}$ is needed.
While this is supported by the standard GIST implementation, it is rarely done due to the large size of the $E_{ww,kl}$ matrix.

We note that replacement of a small or medium solvent region would lead to reorganization of the surrounding solvent.
However, this depends on the local environment and on \emph{what} the molecule would be replaced by.
Therefore, the effect of reorganization can not be directly included in the GIST method, but must be judged for each case individually.
This is not a problem when computing the total free energy of solvation $\dgsolv$, since no additional boundary is created.
\todo{Do we need this paragraph?}



\subsection{PME implementation}

In the original version of GIST, the energies are calculated based on the the minimum image convention.
In PME-GIST, the electrostatics are calculated using the particle mesh Ewald (PME) method, which yields energies that are highly consistent with the treatment in the Amber MD engine \cite{Chen2021}.
The electrostatic and Lennard-Jones parts $E_\text{elec}$ and $E_\text{lj}$ are computed separately.
\todo{E$_{LJ}$ seems more intuitive to me, need to check what the GIST literature is using -vah. They use $E_{lj}$, but LJ in the text -fwa.}
\begin{equation}
	E_\text{total} = E_\text{elec} + E_\text{lj}
\end{equation}

In PME-GIST, the system is treated as periodic, and the electrostatic energy is split into a short-range term $E_\text{dir}$, which is calculated in direct space using a distance cutoff, and a long-range term $E_\text{rec}$, which is calculated in reciprocal space.
Additionally, there is a correction term $E_\text{corr}$, which corrects for the self-interaction of each solvent molecule in the reciprocal term.

\begin{equation}
	E_\textit{elec} = E_\textit{dir} + E_\textit{rec} + E_\textit{corr}
\end{equation}
%\todo{How is E$_{dir}$ treated? Is there a cutoff as well (PME GIST paper seems to indicate so)? If so, we should probably note that. } - ok? -fwa
The Lennard-Jones contribution is computed in the direct space, using a distance cutoff. The short-range contribution is the LJ energy within the set cutoff and the long-range correction term accounts for the contributions above this cutoff.

\begin{equation}
	E_\textit{lj} = E_\textit{lj,\ short} +  E_\textit{corr}
\end{equation}

\section{Tutorial}
Here, we aim to guide the reader through a GIST analysis of the streptavidin-biotin complex. The goal is to
\begin{enumerate}
	\item compute the binding free energy of the complex from the individual energy contributions combined with the contribution of hydration computed using GIST.
	\item visualize local contributions to $\dgsolv$ in the streptavidin binding pocket as well as around biotin.
\end{enumerate}
\todo{include: learn how to setup ad run a gist calculation}

\subsection{Streptavidin/Biotin}
\subsection{Tutorial data}
We will use the 1STP crystal structure to start our calculations.
For the sake of simplicity, you can download prepared and solvated Amber topologies and structures based on 1STP by running
\begin{lstlisting}
git clone git@github.com:liedllab/gist-tutorial.git
\end{lstlisting}
This will download the tutorial files (including both the manuscript and the examples in the \software{code} folder).
\subsection{System Preparation and Equilibration}
If you want to skip this section, run 
\begin{lstlisting}
make equilibration-targets
\end{lstlisting}
in the code folder. This assumes that you have Python and Amber set up properly and that \software{pmemd.cuda} is in the PATH.

When calculating solvation free energy differences between a complex and the corresponding monomers (the dissociated state), there are two options for dealing with configurational diversity in the structures.
\todo{Maybe Valentin knows a citation for that?}
One can choose to sample the complex and dissociated states individually, or to sample only one of them and assume that there is sufficient overlap in the sampled conformations.
%One can choose to sample only the complex, assuming that all relevant conformations of the dissociated state are also found in the complex.
%The probability distribution of the dissociated state can be obtained by reweighting the probabilities in the complex using the solvation free energies.
%Alternatively, one can sample the complex and dissociated states individually.
%This approach does not require an overlap between the conformational probabilities of the complex and dissociated states.
%However, it is prone to statistical errors due to uncertainties in the ensembles, and requires the free energy contributions from the internal degrees of freedom of the monomers (in both the complex and the monomer states) to be known. \todo{This paragraph does not fit here well. Maybe put it somewhere else.}

Here, we choose not to include any sampling of the conformational states. 
It is therefore important that the conformations of the monomers in the complex and dissociated states match exactly. 
Use \software{cpptraj} to produce biotin and streptavidin structures based on the complex by stripping the respective other molecule like this:
\begin{lstlisting}
parm complex/solvated.parm7
trajin complex/equil/EQUIL-DONE.rst
strip ^2 parmout streptavidin/solvated.parm7
trajout streptavidin/pre-equil.ncrst
\end{lstlisting}
(Adapt for biotin as necessary.)
\todo{vah: Maybe include a section on how to prepare a protein structure before equilibration. Protonation, force field and a large enough iso solvation box seem important to me. I will probably also at least mention what simulation settings we are running later on.}
%We provide a script called \software{cpptraj\_remove\_mol.sh} that removes a single molecule from a topology and structure using \software{cpptraj} without altering the rest of the system. \todo{Explain cpptraj rather than our script. The script is for the automated workflow only.}

Use the \software{equilibration.py} script (or your own) to perform short NVT and NpT equilibration runs on the starting structure.
\todo {NPT}
Note that the barostat might interfere with restrained equilibration of the complex, since different molecules are moved relative to each other when the volume changes.
But since our equilibration script also contains unrestrained pressure equilibration, we should not run into any trouble.

Then split the equilibrated structure into biotin and streptavidin parts using \software{cpptraj\_remove\_mol.sh}.
After that, you can use \software{equilibration.py -R} to run short restrained equilibrations (where only the water is allowed to move) on the individual systems.

\subsection{Running MD for GIST}

Now, you can run restrained MD simulations based on the equilibrated structures for subsequent GIST analyses.
\todo {explain why the protein needs to be restrained for an MD simulation that will be analyzed using GIST}
We apply a harmonic restraint of \SI{100}{\kilo\calorie\per\mole\per\angstrom\squared} to all heavy atoms to keep the system in place.
We run \SI{100}{\nano\second} of simulation and store the conformations every \SI{100}{\pico\second}.
A simulation length of at least \SIrange{10}{20}{\nano\second} is recommended, to obtain statistically independent snapshots of the water.

An example Amber input file for GIST might look like this:
\begin{lstlisting}
restrained 100 ns NpT
&cntrl
  ntx=5, irest=1,
  ioutfm=1,
  ntb=2, iwrap=1,
  ntr=1, restraint_wt=100.0,
    restraintmask="!@H=&!:WAT",
  ntp=1, pres0=1.0, taup=1.0,
  ntc=2, ntf=2,
  ntt=3, tempi=300.0, temp0=300.0, gamma_ln=2,
  nstlim=50000000, dt=0.002,
  ntwr=50000, ntwx=5000,
  ntpr=5000,
/
\end{lstlisting}
Note that these are very standard MD settings except for the line that defines the restraints.

Run the MD using \software{pmemd.cuda}:
\begin{lstlisting}
pmemd.cuda \
	-O \
	-i 100ns-npt-restraint.in \
	-o md-01.out \
	-p solvated.parm7 \
	-c EQUIL-DONE.rst \
	-x md-01.nc \
	-r md-01.ncrst \
	-ref EQUIL-DONE.rst
\end{lstlisting}

\subsection{Running the GIST analysis}
GIST analysis can be divided in three steps: defining a region of interest, running GIST using \software{cpptraj}, and post-processing and analysis.
\cite{Ramsey2016}

\paragraph{Identify and define the region of interest}
In order to run a GIST analysis, the region where the solvent properties will be calculated must be first defined. This region is represented by a rectangular prism centered at (x, y, z) with $N_x \times N_y \times N_z$ voxels, where each voxel is cubic with a sidelength of \inlinecode{gridspacn}.
While integrals over GIST quantities are independent of the voxel size, individual voxel values converge slower at high resolutions.\pdfcomment{The calculation actually can actually get faster at higher resolution, because the same grid is used in the nearest-neighbor search.}
A default value of 0.5 A is used that provides reasonable discretization for many use-cases.

In \software{ccptraj}, the rectangular prism is defined by parameters of the \inlinecode{gist} command.
The center of the grid is defined by \inlinecode{gridcntr}, the dimensions of the grid is defined by \inlinecode{griddim}, and the spacing is defined by \inlinecode{gridspacn}.

\begin{lstlisting}
gist gridcntr <x> <y> <z> \
     griddim <Nx> <Ny> <Nz> gridspacn <val>
\end{lstlisting}


The region can be defined using a ligand in a specific binding pocket of the protein, a specific residue of the protein, or the whole protein itself. A helper script FindCentroid.py \todo{(upload FindCentroid.py!)} can be used to determine the centroid of the region of interest as well as the dimensions of the rectangular prism that will fully enclose the region. A pdb file is needed as an input and the rectangular prism will be centered based on the centroid of the given structure.

\begin{lstlisting}
python FindCentroid.py -i structure.pdb
\end{lstlisting}

\paragraph{Run GIST using cpptraj}
\todo{GIST is incorporated in cpptraj which requires the topology and the trajectory of the MD simulation to be analayzed. The commands needed to run GIST in cpptraj can be written in an input file (e.g gist.in) for convenience. The basic comands are:}

\todo{parm topology.prmtop}
\todo{trajin trajectory.nc 1 10000}
\todo{gist gridcntr 10.5 20.1 30.1 griddim 30 30 30 gridspacn 0.50 out gist.dat}
\todo{go}

\todo{The first line specifies the amber topology file that was used to run MD. The second line species the trajectory file and what frames to be analyzed. In the above example, GIST will be run from frame 1 to 10000. The third line tells cpptraj to run a GIST calculation using the region defined and print the output of the calculation in a file called gist.dat. The last instructs cpptraj to run the calculation. The syntax for running cpptraj given this input file is:}

\begin{lstlisting}
cpptraj -i gist.in
\end{lstlisting}
	
\pdfcomment{Franz: I removed the list because it is very long and not complete. We can add it to the lists at the end, but then it should be complete.}
%\todo{Aside from the commands defining the region of interest, there are other options available to specify the GIST analysis. Here is the full list that can be added to the third line of the input file:} 
%\begin{itemize}
%	\item{[doorder] Calculate the water order parameter [reference] for each voxel.}
%	\item{[doeij] Calculate the triangular matrix representing the water-water interactions between pairs of voxels (see below).}
%	\item{[skipE] Skip all energy calculations (cannot be specified with ’doeij’).}
%	\item{[skipS Skip all the entropy calculations.]}
%	\item{[refdens rdval>] Reference density of bulk water, used in computing $g_O, g_H$, and the translational entropy. Default is 0.0334 molecules/Å3.}
%	\item{[temp <tval>] Temperature of the input trajectory.}
%	\item{[noimage] Disable distance imaging in energy calculation.}
%	\item{[gridcntr <xval> <yval> <zval>] Coordinates (Å) of the center of the grid (default 0.0, 0.0, 0.0).}
%	\item{[griddim <xval> <yval> <zval>] Grid dimensions along each coordinate axis (default 40, 40, 40).}
%	\item{[gridspacn <spaceval>] Grid spacing (linear dimension of each voxel) in Angstroms. Values greater than 0.75 Å are not recommended (default 0.5 Å).}
%	\item{[prefix <filename prefix>] Output file name prefix (default “gist”).}
%	\item{[ext <grid extension>] Output grid file name extension (default “.dx”).}
%	\item{[out <output>] Name of the main GIST output file. If not specified set to ’<prefix>-output.dat’.}
%	\item{[info <info>] Name of main GIST info file. If not specified info is written to standard output.}
%\end{itemize}

\paragraph{Postprocessing and Analyzing GIST results}
Cppraj outputs the quantities calculated in a data explorer "DX" file format which can be easily visualized in Pymol or VMD.
Aside from the thermodynamic quantities, GIST also calculates the number densitiies of hydrogen and oxygen in each voxel. Here is a full list of quantities calculated by GIST \todo{This is incomplete!}:

\begin{itemize}
	\item{[gO] Number density of oxygen centers found in the voxel, in units of the bulk density.}
	\item{[gH] Number density of hydrogen centers found in the voxel in units of the reference bulk density.}
	\item{[Esw] Mean solute-water interaction energy density.}
	\item{[Eww] Mean water-water interaction energy density.}
	\item{[dTStrans] First order translational entropy density.}
	\item{[dTSorient] First order orientational entropy density .}
	\item{[neighbor] Mean number of waters neighboring the water molecules found in this voxel multiplied by the voxel number density.}
	\item{[dipole] Magnitude of mean dipole moment (polarization).}
	\item{[order] Average Tetrahedral Order Parameter.}
	\item{[dipolex] x-component of the mean water dipole moment density}
	\item{[dipoley] y-component of the mean water dipole moment density}
	\item{[dipolez] z-component of the mean water dipole moment density}
	\item{[Eij] Water-water interaction matrix.}
\end{itemize}

\todo{There are default dx files that will be written as an output, such as the dx files for energies, entropies, number density of oxygen, and number density of hydrogen. All quantities mentioned above is written in the output file (output.dat) and can be used to generate DX files for other quantities.}

\subsection{Running the GIST analysis for Streptavidin-Biotin Complex}
For easier post-processing, we will use grids that contain the whole molecule.
This could in theory be avoided for streptavidin and the complex, since only the surrounding of the biotin molecule (i.e., the binding pocket) is required for the analysis.
We also recommend that you center the molecule in space.
For each system (biotin, streptavidin, complex), produce a centered pdb file using \software{cpptraj}:
\begin{lstlisting}
parm solvated.parm7
trajin md-01.nc 1 1 1
autoimage !(:WAT) origin
strip :WAT
trajout solute-centered.pdb
\end{lstlisting}
Then, find the extent (minimum and maximum) of the x-, y-, and z-coordinates for each system.
This can be done e.g., using the \software{mdtraj} package in Python.
\begin{lstlisting}[style=python]
import mdtraj as md
pdb = md.load("solute-centered.pdb")
# mdtraj converts to nm.
# *10 to convert back to Angstrom.
min = pdb.xyz[0].min(0) * 10.
max = pdb.xyz[0].max(0) * 10.
print(*list(zip("xyz", min, max)), sep="\n")
\end{lstlisting}
Then, decide on grid dimensions for every system.
For a system centered at the origin with a spacing of \SI{0.5}{\angstrom} and a buffer of, e.g., \SI{7}{\angstrom} between the solute and the grid wall, you need $4.0\times (d+7)$ bins in the respective direction, where $d$ is the larger of $-$min and $+$max in the respective direction.
\todo{this does not work with the default gisttools values for the automatic detection of the energy reference. Better use a larger value. }
We note that this centered grid is usually larger than it needs to be in some directions.
If you want to save some extra memory and calculation time, feel free to align the grid more precisely to the minimum and maximum coordinates, or use a smaller grid that only covers the binding pocket.
You can also rotate the molecule by its principal axes to fit the cuboid grid more exactly.
However, this needs to be done \emph{before} the MD run, since rotating the trajectory damages the periodic box information.

Now, you can finally run the actual GIST analysis. Center the molecule exactly in the same way as above, to make sure that its position matches the grid parameters that you decided on.
We recommend using either the PME or GPU implementation of GIST, depending on whether you have a fast GPU.
A further advantage of the PME implementation is that it matches the energy calculation of the MD engine more closely.

\begin{lstlisting}
parm solvated.parm7
trajin md-01.nc
autoimage !(:WAT) origin
# remove the "pme" option if you want to use the GPU
gist griddim 100 100 100 out gist.dat \
  refdens 0.03287 pme
# other settings you might want to change
# (those are the defaults)
# gridcntr 0 0 0 gridspacn 0.5 temp 300
\end{lstlisting}
\subsection{Reference Values and Radial Convergence}
All GIST quantities should be expressed relative to bulk. In practice, this is not problematic for the entropies, since they are computed relative to a distribution of randomly oriented molecules at the reference density.
The solute-solvent energy $E_{sw}$ is also no problem, because it naturally tends to zero in bulk. 
However, the solvent-solvent energy $E_{ww}$ needs to be referenced.

The Amber manual provides reference energies for several solvents.
However, the exact reference value is different when using PME-GIST, and also depends on the box size.
For exact analyses such as computing the total $\dgsolv$ of a compound, it is important to compute an exact reference energy.

The most accurate method to compute a reference energy is to run a separate GIST calculations with the same energy method (PME/GPU) and a similar box size, and then compute the average solvent-solvent energy per molecule.

\begin{equation}
\label{eq_ewwref}
E_{ww}^\textit{ref} = \frac{\int{E_{ww}} \mathrm{d}x}{\left<N_\textit{solvent}\right>}
  = \frac{\sum_\textit{voxels}E_{ww}^\textit{dens} V_\textit{vox}}{\sum_\textit{voxels}{N_\textit{solvent}} / N_\textit{frames}}
\end{equation}

Alternatively, one can note that the solvent-solvent energy in a sufficiently large GIST grid converges to the correct bulk value at large distance to the solute.
This means that the reference energy can be obtained from a large GIST grid by binning the voxels by their distance to the solute, and evaluate Equation~\ref{eq_ewwref} within each bin.
If this value converges to a constant, this can be used as $E_{ww}^\textit{ref}$.

\software{gisttools} contains functionality to perform this analysis easily.
There is also a method \inlinecode{detect\_reference\_value} that automatically tries to find the converged value from the rdf.
Although it has a simple convergence check built-in, it is always recommended to check the convergence by hand as well.

\begin{lstlisting}[style=python]
import gisttools as gt
import matplotlib.pyplot as plt
gist = gt.gist.load_gist_file(
    "gist.dat", struct="solute-centered.pdb")
bins, eww = gist.rdf(
    "Eww_unref_norm", bins=100, rmax=20., normalize="norm")
plt.plot(bins, eww)
eww_auto = gist.detect_reference_value().values[0]
plt.axhline(eww_auto, color='k')
plt.gca().set(
    xlabel='distance [A]', ylabel='E_ww per mol')
plt.show()
\end{lstlisting}
\todo{While not massively important, I don't like that we call the gist object here "gist", as that's the same name as gisttools subpackage gist. "gt.gist.bla" and "gist.bla" therefore look quite similiar, but do very different things. -vah}
The expected output of this code is shown in Figure~\ref{fig_ewwref}.

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{figures/Eww_convergence.eps}
	\caption{Convergence of $E_{ww}$ with increasing distance to the solute. The horizontal line shows the automatically computed reference energy. Computed from the complex calculation.}\label{fig_ewwref}
\end{figure}

After choosing an appropriate reference value, we need to subtract this value from $E_{ww}$.
Make sure to subtract the reference from the normalized (\_norm) data.
In \software{gisttools}, this is done simply by setting \inlinecode{gist.eww\_ref}.
In \software{gistpp}, this can be done as follows: 
\todo{Is there some official documentation for gistpp? We should probably link that somewhere, I feel that the code presented here is not really helpful/legible without further documentation. -vah}
\todo{This might become invalid with future GIST versions, depending on whether we adopt the COM as molecular center.} 
\todo{Better use the population.}

\begin{lstlisting}
rho0=0.03287465
neg_eww_ref=9.533
gistpp -op multconst -i gist-gO.dx -opt const $rho0 \
    -o gist-gO-abs.dx 
gistpp -op div -i gist-Eww-dens.dx -i2 gist-gO-abs.dx \
    -o gist-Eww-norm.dx
gistpp -op addconst -i gist-Eww-norm.dx \
    -opt const $neg_eww_ref -o gist-Eww-ref-norm.dx
gistpp -op mult -i gist-Eww-ref-norm.dx \
    -i2 gist-gO-abs.dx -o gist-Eww-ref-dens.dx
\end{lstlisting}

Now, add all free energy contributions to obtain the spatially resolved $\dgsolv$.
In \software{gisttools}, this is done automatically (simply use the \inlinecode{A\_dens} and \inlinecode{A\_norm} columns).
In \software{gistpp}, use the \inlinecode{add} command, with the same syntax as the \inlinecode{div} command used above.
After that, check whether your free energy contributions become negligible at high distances to the solute.
In a plot like Figure~\ref{fig_ewwref} based on the \inlinecode{A\_dens} column, the values should tend to zero.
However, it is more informative to plot the cumulative free energy contribution against the distance to the solute, to check the convergence.
It the curve flattens out, the converged value is your final $\dgsolv$\@.
If it does not, you might need to tweak the $E_{ww}$ reference, or introduce a reference value for the entropy (especially with older versions of \software{cpptraj}).
% \todo{Eww or E$_{ww}$? Doesn't seem consistent so far. -vah} - let's go with all math mode $E_{ww}$ -fwa

\begin{lstlisting}[style=python]
import gisttools as gt
import matplotlib.pyplot as plt
# adapt eww_ref!
gist = gt.gist.load_gist_file("gist.dat",
    struct="solute-centered.pdb", eww_ref=-9.533)
bins, (dg, esw, eww, s) = gist.rdf(
    ["A_dens", "Esw_dens", "Eww_dens", "dTSsix_dens"],
    bins=100, rmax=20., normalize="none")
plt.plot(bins, np.cumsum(dg), label="dG")
plt.plot(bins, np.cumsum(eww), label="Eww")
plt.plot(bins, np.cumsum(esw), label="Esw")
plt.plot(bins, np.cumsum(s), label="dS")
\end{lstlisting}

The expected output of this code is shown in Figure~\ref{fig_radial_convergence}.
Both the solvent-solvent energy and the entropy are not perfectly flat, indicating that the reference value is not optimal.
The slow energy convergence indicates that a non-optimal reference value was used, but is also complicated by the fact that a charged solute is used.
In this case, both the entropy and $E_{sw}$ can be considered converged around \SI{10}{\angstrom}.
While this is not true for $E_{ww}$, we will see below that the energy difference upon binding converges more readily than its individual contributions.
\todo{vah: Is that shown somewhere yet?}

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{figures/A_E_S_convergence.eps}
	\caption{Convergence of $\dgsolv$ and its contributions with increasing distance to the solute. All quantities cumulative, i.e., summed up to the respective radius. Computed from the biotin calculation.}\label{fig_radial_convergence}
\end{figure}

\subsection{Visualizing $\dgsolv$}
Next, we want to visualize the 3-dimensional contributions to the free energy of hydration, as well as the entropy and enthalpy contributions.
You can use PyMol\cite{pymol} or VMD\cite{vmd} to visualize the .dx files from GIST\@.
With \software{gistpp}, you can use the file from the convergence check. Additional OpenDX files can be produced using \inlinecode{gistpp -op makedx}.
With \software{gisttools}, you can create one using e.g., \inlinecode{gist.save\_dx("A\_dens", "A\_dens.dx")}.

It might also be interesting to visualize the average energy of a water molecule at each grid voxel.
This quantity is given by 2*Eww + Esw.
The energy referencing leads to non-zero normalized values where the population is zero.
While this is irrelevant for further post-processing, it is advantageous for visualization to set those empty regions to zero.
An OpenDX file can be produced using \software{gisttools} as follows:

\begin{lstlisting}[style=python]
import gisttools as gt
gist = gt.gist.load_gist_file("gist.dat",
    struct="solute-centered.pdb", eww_ref=-9.533)
gist['E_norm'] = gist['Eww_norm'] * 2 + gist['Esw_norm']
gist.loc[gist['population'] == 0, 'E_norm'] = 0
gist.save_dx('E_norm', 'gist-E-per-mol-norm.dx')
\end{lstlisting}

Visualize the free energy, the total energy, and the entropy, at several iso-levels.
A minimal PyMOL input might look like this:

% The current font makes the O look like a tofu / placeholder
\begin{lstlisting}
load solute-centered.pdb
show sticks, resname BTN
as surface, not resname BTN
load gist-gO.dx, gO
isosurface gO_high, gO, 2.
\end{lstlisting}

Adapt the above PyMOL script to visualize the average energy per solvent at a positive and a negative isolevel, as well as regions of negative entropy per solvent.
The expected representation of the streptavidin binding pocket is shown in Figure~\ref{fig_binding_pocket_pymol}.

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{figures/binding_pocket_S_-2_E_-2_E_3.png}
	\caption{Free energy contributions in the streptavidin binding pocket. Red: high solvent energy (at +3 kcal/mol). Blue: low solvent energy (at -2 kcal/mol). Green: low solvent entropy $T\Delta S^{six}$ (at -2 kcal/mol).}\label{fig_binding_pocket_pymol}
\end{figure}

You should find that there are several regions in the binding pocket that feature a high solvent energy and/or low solvent entropy.
However, such regions also exist outside of the binding pocket, and there are also low-energy regions within the binding pocket.
Therefore, the strong affinity to biotin can not be explained solely by the hydration contribution, and the direct interaction energy also needs to be taken into account.

\subsection{Contribution of Hydration to Binding}
In the next step, calculate the $\dgsolv$ contributions around the biotin ligand in each of the three systems (biotin, streptavidin, and complex).
Note that our integration region does not fully reach into bulk, but also comprises regions that are close to the streptavidin protein. 
Therefore, our results for each system will depend on the exact position of the integration boundary. 
To avoid inconsistencies, it is important to choose exactly the same integration region for each system.
Although we kept the systems rigid, the center of mass might have been shifted during pressure equilibration.
Therefore, we align the complex structure to the streptavidin system and use the shifted biotin coordinates to define the integration region.

We recommend using a \software{Jupyter Notebook} for the following analyses, although they can also be done in a script or an interactive Python prompt.
The code is not explained in detail here, but should be clear after reading the previous sections.

Load the files and double check the frame numbers and reference density.
\begin{lstlisting}[style=python]
import numpy as np
from gisttools.gist import load_gist_file
import matplotlib.pyplot as plt

compl = load_gist_file('complex/gist/gist.dat', \
    struct='complex/gist/solute-centered.pdb')
print(compl.n_frames, compl.rho0)
biotin = load_gist_file('biotin/gist/gist.dat', \
    struct='biotin/gist/solute-centered.pdb')
print(biotin.n_frames, biotin.rho0)
strept = load_gist_file('streptavidin/gist/gist.dat', \
    struct='streptavidin/gist/solute-centered.pdb')
print(strept.n_frames, strept.rho0)
\end{lstlisting}
\todo{Maybe add more complete print calls? E.g. print('Biotin: Frames=\{biotin.n\_frames\}, Rho=\{biotin.rho0\} -vah)}
Assign reference energies and check them for plausibility.
\begin{lstlisting}[style=python]
biotin.eww_ref = biotin.detect_reference_value()
print("Biotin:", biotin.eww_ref)
strept.eww_ref = strept.detect_reference_value()
print("Streptavidin:", strept.eww_ref)
compl.eww_ref = compl.detect_reference_value()
print("Complex:", compl.eww_ref)
\end{lstlisting}

Subtract a reference entropy from the dTSsix columns.
\todo{Is there actually a reason why this is not in gisttools itself implemented? -vah}
\begin{lstlisting}[style=python]
def reference_entropy(gf):
    if 'dTSsix_unref_norm' not in gf.data.columns:
        gf['dTSsix_unref_norm'] = gf['dTSsix_norm']
        gf['dTSsix_unref_dens'] = gf['dTSsix_dens']
    gf['dTSsix_norm'] = gf['dTSsix_unref_norm'] \
        - gf.detect_reference_value('dTSsix_unref_dens')
    gf['dTSsix_dens'] = gf.norm2dens(gf['dTSsix_norm'])
reference_entropy(biotin)
reference_entropy(strept)
reference_entropy(compl)
\end{lstlisting}

Compute the atom positions that define the integration region.
For the streptavidin integral, we align the complex structure onto streptavidin and then use the biotin positions as centers.
Note that we use \software{mdtraj} here, since \software{gisttools} stores the reference structure as a \inlinecode{mdtraj.Trajectory} object, but any other library for post-processing of trajectories works as well.
\begin{lstlisting}[style=python]
col = 'dTSsix_dens'
def select(traj, sel):
    "Slice a Trajectory by selection mask."
    return traj.atom_slice(traj.top.select(sel))
# we multiply by 10 to convert nm to Angstrom.
compl_x = select(compl.struct, biotin_mask).xyz[0] * 10.
biotin_x = select(biotin.struct, biotin_mask).xyz[0] * 10.
aligned = compl.struct[:].superpose(strept.struct, \
    atom_indices=strept.struct.top.select(strept_mask))
aligned = select(aligned, biotin_mask)
strept_x = aligned.xyz[0] * 10.

bins, biotin_rdf = biotin.rdf( \
    col, centers=biotin_x, bins=100, rmax=24)
bins, strept_rdf = strept.rdf( \
    col, centers=strept_x, bins=100, rmax=24)
bins, compl_rdf = compl.rdf( \
    col, centers=compl_x, bins=100, rmax=24)
\end{lstlisting}

Now, subtract the monomer rdfs from the complex, and compute the integrals.
If you also visualize the individual rdfs, you will notice that the difference converges much better with increasing radius than the contributions.
This is because the cutoff contains regions that are close to the atom, since the integration region does not comprise the whole protein.

\begin{lstlisting}[style=python]
difference = compl_rdf - biotin_rdf - strept_rdf
cutoff = 12
integral = difference[bins < cutoff].sum()
print("Integral = {}".format(integral))
plt.plot(bins, np.cumsum(difference))
plt.axvline(cutoff)
plt.xlabel('distance to biotin [Å]')
plt.ylabel('dG contribution [kcal/mol]')
\end{lstlisting}
% \todo{\$\textbackslash AA\$ should produce an angstrom sign in matplotlib (what a pain to have this printed out in \LaTeX\ tho) -vah} -- Å produces an angstrom sign ;-)
Compute the energy (\inlinecode{Eall}) and entropy (\inlinecode{dTSsix}) contributions separately.
You will find that the energy is strongly unfavorable to binding, because we do not yet include the interaction energy between biotin and streptavidin.

Using the \inlinecode{energy} command in \software{cpptraj}, you can compute this energy difference.
We recommend using PME in combination with PME-GIST, but not with GPU-GIST\@.
An example \software{cpptraj} input might look like:
\begin{lstlisting}
parm solvated.parm7
trajin md-01.nc 1 last 100
energy complex ^1,2 # etype pme
energy strept ^1 # etype pme
energy biotin ^2 # etype pme
go
diff = complex[total] - strept[total] - biotin[total]
writedata energy.dat diff complex[total] \
strept[total] biotin[total]
avg(complex[total])
avg(strept[total])
avg(biotin[total])
avg(diff)
\end{lstlisting}

It has been shown in literature \cite{Chen2021,Waibl2022-gist-solvents} that the total solvation entropy in water is best approximated by 0.6 times the first order entropy.
Also compute the scaled entropy and check the effect on the binding affinity.
The expected results are summarized in Table~\ref{tab_dg_monomers_dimer}.
%\todo{Table 1 is placed quite akwardly at the moment for me, maybe enforce its position? -vah. Ok? -fwa}
\begin{table}[h]
	\caption{Free energy contributions for the monomers and the dimer.}\label{tab_dg_monomers_dimer}
	\small
	\begin{tabular}{lrrrrr}
		\toprule
		System       & E(internal) & $\Delta E^\textit{GIST}$ & $\Delta S^\textit{GIST}$ & $\Delta S^\textit{scaled}$ & total \\
		\midrule
		complex      & -1303.4 & -361.2 & -233.1 & -139.9 & -192.0 \\
		streptavidin & -1180.7 & -360.8 & -242.4 & -145.4 & -188.4 \\
		biotin       & -24.0   &  -98.1 &  -35.1 &  -21.1 & -105.4 \\
		Diff         & -98.7   &   97.7 &   44.4 &   26.6 &  -27.6 \\
		\bottomrule
	\end{tabular}
\end{table}

Even though streptavidin-biotin is known to be a very stable complex, the solvation energy favors the dissociation.
This is expected: if the molecules were not able to form any interactions, but interacted fully with the water, they would not form a complex.

In this case, we find that the energy of solvation and the internal energy of the complex more or less cancel out, indicating that binding is largely entropy-driven in this case.
At first, this is surprising, since isothermal titration calorimetry (ITC) of biotin-streptavidin shows strong enthalpic binding contributions \cite{mpye2020-biotin-itc,hyre2006-biotin-itc}.
However, we do not take the conformational transition of the streptavidin binding pocket into account.
Prior computational studies suggest a $\Delta G$ of \SI{-26.6}{\kilo\calorie\per\mole} for the binding of biotin into the closed conformation of streptavidin \cite{Bansal2018-biotin}.
This indicates that our result is in good agreement with literature.
However, the conformational changes of the binding pocket would need to be described to improve the agreement with experiments.
\todo{Should we include a short introduction to other solvents with GIST? What about solvent/ion mixtures? Can we somehow distinguish python code from input files optically? -vah}
\subsection{Further steps}
In this tutorial, we obtained a value for the binding of biotin into the closed conformation of the streptavidin binging pocket.
To investigate the effect of different conformations on the binding affinity, you can perform molecular dynamics simulations of the complex and/or monomers and perform GIST on multiple cluster representatives.
To include the effect of the lid closing transition in the binding process, free energy calculation methods such as umbrella sampling can be used.
%\section{Content and links}
%
%A tutorial will normally draw on additional files and materials; clearly indicate where and how these are available, with links, and how they are being archived for the long-term and maintained so they stay current.
%You will likely want to reference your GitHub repository as a central point to access all of this information, and then the GitHub repository may link out to other content as needed.

\section{Recent developments}
\subsection{GIST with non-water solvents}
\subsection{GIST with salt-water mixtures}

\section{Checklists}
%Tutorials do not necessarily require the use of a checklist as in Best Practices documents; however, they can include these if desired.
%Several useful checklist formats are available, with examples presented in \texttt{sample-document.tex} in \url{github.com/livecomsjournal/article_templates/templates}.
%One example is shown here.

% Here is a single-column checklist that consists of multiple sub-checklists
\begin{Checklists}[h]

\begin{checklist}{Simulation settings}
\textbf{Each number denotes the minimum setting, with the optimum in brackets.}
\begin{itemize}
	\item Simulation time: \SIrange{10}{20}{\nano\second} (\SI{100}{\nano\second})
	\item Number of analyzed frames: \num{10000} (\num{100000})
	\item Restraints: typically \SI{100}{\kcalPerMolASqr} on solute heavy atoms.
\end{itemize}
\end{checklist}

\begin{checklist}{Choosing an energy method}
\begin{itemize}
	\item GPU, direct space: generally the fastest
	\item CPU, PME: highly consistent with Amber MD, fast
	\item CPU: slow, most general (can write out $E_{ij}$ matrices)
\end{itemize}
\end{checklist}

\begin{checklist}{Obtaining absolute $\Delta G_\textup{solv}$}
\begin{itemize}
	\item Check the radial convergence (see Fig.~\ref{fig_radial_convergence})
	\item Choose a sufficient distance cutoff
	\item Choose an optimal $E_{ww}$ reference value
	\item Tweak simulation length and number of frames to obtain smooth free energy contributions and unbiased (i.e., zero) bulk entropy.
	\item If necessary, subtract an entropy reference
\end{itemize}
\end{checklist}

%\begin{checklist}{A list}
%\textbf{Single-column checklists are also straightforward by removing the asterisk}
%\begin{itemize}
%\item First thing let's do an item which breaks across lines to see how that looks
%\item Also remember
%\item And finally
%\end{itemize}
%\end{checklist}
%
%\begin{checklist}{Another list}
%\textbf{This is some further description.}
%\begin{itemize}
%\item First thing
%\item Also remember
%\item And finally
%\end{itemize}
%\end{checklist}

\end{Checklists}








\section*{Author Contributions}
%%%%%%%%%%%%%%%%
% This section mustt describe the actual contributions of
% author. Since this is an electronic-only journal, there is
% no length limit when you describe the authors' contributions,
% so we recommend describing what they actually did rather than
% simply categorizing them in a small number of
% predefined roles as might be done in other journals.
%
% See the policies ``Policies on Authorship'' section of https://livecoms.github.io
% for more information on deciding on authorship and author order.
%%%%%%%%%%%%%%%%

(Explain the contributions of the different authors here)

% We suggest you preserve this comment:
For a more detailed description of author contributions,
see the GitHub issue tracking and changelog at \githubrepository.

\section*{Other Contributions}
%%%%%%%%%%%%%%%
% You should include all people who have filed issues that were
% accepted into the paper, or that upon discussion altered what was in the paper.
% Multiple significant contributions might mean that the contributor
% should be moved to authorship at the discretion of the a
%
% See the policies ``Policies on Authorship'' section of https://livecoms.github.io for
% more information on deciding on authorship and author order.
%%%%%%%%%%%%%%%

(Explain the contributions of any non-author contributors here)
% We suggest you preserve this comment:
For a more detailed description of contributions from the community and others, see the GitHub issue tracking and changelog at \githubrepository.

\section*{Potentially Conflicting Interests}
%%%%%%%j
%Declare any potentially competing interests, financial or otherwise
%%%%%%%

Declare any potentially conflicting interests here, whether or not they pose an actual conflict in your view.

\section*{Funding Information}
%%%%%%%
% Authors should acknowledge funding sources here. Reference specific grants.
%%%%%%%
FMS acknowledges the support of NSF grant CHE-1111111.

\section*{Author Information}
\makeorcid

\bibliography{bibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% APPENDICES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\appendix


\end{document}
